{
  "hash": "71cb665a2862b1d8da734f884233218a",
  "result": {
    "markdown": "---\ntitle: \"Unit tests\"\nformat: revealjs\nknitr: \n  opts_chunk: \n    cache: true\n---\n\n\n## I urge you to consult:\n\n[Carnegie Mellon's 36-750 Notes](https://36-750.github.io)\n\nThank you Alex and Chris for the heavy lifting.\n\n\n\n\n\n\n## Bugs happen. All. The. Time.\n\n* the crash of the [Mars Climate Orbiter](https://en.wikipedia.org/wiki/Mars%5FClimate%5FOrbiter) (1998),\n\n* a [failure of the national telephone network](https://telephoneworld.org/landline-telephone-history/the-crash-of-the-att-network-in-1990/) (1990),\n\n* a deadly medical device ([1985](https://en.wikipedia.org/wiki/Therac-25), 2000),\n\n* a massive [Northeastern blackout](https://en.wikipedia.org/wiki/Northeast%5Fblackout%5Fof%5F2003) (2003),\n\n* the [Heartbleed](http://heartbleed.com/), [Goto Fail](https://www.dwheeler.com/essays/apple-goto-fail.html), [Shellshock](https://en.wikipedia.org/wiki/Shellshock%5F(software%5Fbug)) exploits (2012–2014),\n\n* a 15-year-old [fMRI analysis software](http://www.pnas.org/content/113/28/7900.full) bug that inflated significance levels (2015),\n\n. . .\n\nIt is easy to write lots of code.\n\nBut are we sure it's doing the right things?\n\n::: {.callout-important}\nEffective testing tries to help.\n:::\n\n\n## A Common (Interactive) Workflow\n\n1. Write a function.\n1. Try some reasonable values at the REPL to check that it works.\n1. If there are problems, maybe insert some print statements, and modify the function.\n1. Repeat until things seem fine.\n\n(REPL == Read-Eval-Print-Loop, the console, or Jupyter NB)\n\n* This tends to result in lots of bugs.\n\n* Later on, you forget which values you tried, whether they failed, how you fixed them.\n\n* So you make a change and maybe or maybe not try some again.\n\n\n## Example:\n\n\n::: {.cell hash='unit-tests_cache/revealjs/norms_ece051ffded69411dca0c3b3ec15fb5a'}\n\n```{.r .cell-code}\ntwo_norm <- function(x) sum(x^2)\ngrouped_two_norm <- function(x, gr) as.vector(tapply(x, gr, two_norm))\ngr_two_norm <- function(x, gr) sum(grouped_two_norm(x, gr))\n```\n:::\n\n\n* There's a silly bug in the above code. \n\n. . .\n\n* At one point, I decided that I didn't want the $\\ell_2$-norm, I wanted the **squared** $\\ell_2$ norm.\n\n* But now the other two functions are wrong.\n\n\n::: {.callout-note}\nThese functions get used in many other places.\n\nTo make sure I don't do something dumb ever again, I write [unit tests]{.primary}.\n:::\n\n\n## Unit Testing\n\n* A **unit** is a small bit of code (function, class, module, group of classes)\n\n* A **test** calls the unit with a set of inputs, and checks if we get the expected output.\n\n\n::: {.cell hash='unit-tests_cache/revealjs/unnamed-chunk-1_afbee5860fd52427c802d27c4360efef'}\n\n```{.r .cell-code}\ntest_that(\"group norms are correct\", {\n  asparse <- .05\n  gr <- c(1, 1, 1, 1, 2, 2, 3, 3, 3, 3, 3)\n  x <- -5:5\n  expect_equal(two_norm(c(-5 , 5)), sqrt(50)) # this one will fail\n  expect_equal(\n    grouped_two_norm(x, gr),\n    c(two_norm(x[1:4]), two_norm(x[5:6]), two_norm(x[7:11])))\n})\n```\n:::\n\n\nUnit testing consists of writing tests that are\n\n* focused on a small, low-level piece of code (a unit)\n* typically written by the programmer with standard tools\n* fast to run (so can be run often, i.e. before every commit).\n\n\n## Unit testing benefits\n\nAmong others:\n\n* Exposing problems early\n* Making it easy to change (refactor) code without forgetting pieces or breaking things\n* Simplifying integration of components\n* Providing natural documentation of what the code should do\n* Driving the design of new code.\n\n![](http://www.phdcomics.com/comics/archive/phd033114s.gif)\n\n\n## Components of a Unit Testing Framework\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n* Collection of **Assertions** executed in sequence. \n* Executed in a self-contained environment.\n* Any assertion fails `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 512 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:#e98a15;overflow:visible;position:relative;\"><path d=\"M334.5 414c8.8 3.8 19 2 26-4.6l144-136c4.8-4.5 7.5-10.8 7.5-17.4s-2.7-12.9-7.5-17.4l-144-136c-7-6.6-17.2-8.4-26-4.6s-14.5 12.5-14.5 22l0 88L32 208c-17.7 0-32 14.3-32 32l0 32c0 17.7 14.3 32 32 32l288 0 0 88c0 9.6 5.7 18.2 14.5 22z\"/></svg>`{=html} Test fails.\n\nEach test focuses on a single component.\n\nNamed so that you know what it's doing.\n\n\n\n::: {.cell hash='unit-tests_cache/revealjs/unnamed-chunk-2_4b660f3a5ed7d2daefff7d074e1ab773'}\n\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n![](https://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif)\n\n:::\n::::\n\n\n## A test suite\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n* Collection of related tests in a common context.\n\n* Prepares the environment, cleans up after\n\n* (loads some data, connects to database, necessary library,...)\n\n* Test suites are run and the results reported, particularly failures, in a easy to parse and economical style. \n\n* For example, Python’s `{unittest}` can report like this\n::: \n\n::: {.column width=\"50%\"}\n\n```\n$ python test/trees_test.py -v\n\ntest_crime_counts (__main__.DataTreeTest)\nEnsure Ks are consistent with num_points. ... ok\ntest_indices_sorted (__main__.DataTreeTest)\nEnsure all node indices are sorted in increasing order. ... ok\ntest_no_bbox_overlap (__main__.DataTreeTest)\nCheck that child bounding boxes do not overlap. ... ok\ntest_node_counts (__main__.DataTreeTest)\nEnsure that each node's point count is accurate. ... ok\ntest_oversized_leaf (__main__.DataTreeTest)\nDon't recurse infinitely on duplicate points. ... ok\ntest_split_parity (__main__.DataTreeTest)\nCheck that each tree level has the right split axis. ... ok\ntest_trange_contained (__main__.DataTreeTest)\nCheck that child tranges are contained in parent tranges. ... ok\ntest_no_bbox_overlap (__main__.QueryTreeTest)\nCheck that child bounding boxes do not overlap. ... ok\ntest_node_counts (__main__.QueryTreeTest)\nEnsure that each node's point count is accurate. ... ok\ntest_oversized_leaf (__main__.QueryTreeTest)\nDon't recurse infinitely on duplicate points. ... ok\ntest_split_parity (__main__.QueryTreeTest)\nCheck that each tree level has the right split axis. ... ok\ntest_trange_contained (__main__.QueryTreeTest)\nCheck that child tranges are contained in parent tranges. ... ok\n\n---------------------------------------------------------\nRan 12 tests in 23.932s\n```\n\n:::\n::::\n\n\n\n## `R` example\n\n```\nℹ Loading sparsegl\nℹ Testing sparsegl\n✓ | F W S  OK | Context\n✓ |         7 | model_base                                                           \n✓ |         7 | norms                                                                \n⠏ |         0 | predict                                         \nLoading required package: Matrix\nLoaded glmnet 4.1-3\n✓ |        17 | predict [0.4s]                                                       \n✓ |         5 | risk_estimation [0.4s]                                               \n✓ |         5 | sparsegl_comparisons                                                 \n✓ |        18 | sparsegl_params                                                      \n\n══ Results ══════════════════════════════════════════════════════════════════════════\nDuration: 0.9 s\n\n[ FAIL 0 | WARN 0 | SKIP 0 | PASS 59 ]\n```\n\n\n## What do I test?\n\n::: {.callout-tip icon=false}\n## Core Principle:\n\nTests should be passed by a correct function, but not by an incorrect function.\n:::\n\nThe tests must apply pressure to know if things break.\n\n* several specific inputs for which you _know_ the correct answer\n* \"edge\" cases, like a list of size zero or a matrix instead of a vector\n* special cases that the function must handle, but which you might forget about months from now\n* error cases that should throw an error instead of returning an invalid answer\n* previous bugs you’ve fixed, so those bugs never return.\n\n\n## What do I test?\n\nMake sure that incorrect functions won't pass (or at least, won't pass them all).\n\n\n::: {.cell hash='unit-tests_cache/revealjs/unnamed-chunk-3_23a63c38023498572b7316181d8020c0'}\n\n```{.r .cell-code}\nadd <- function(a, b) return(4)\nadd <- function(a, b) return(a * b)\n\ntest_that(\"Addition is commutative\", {\n  expect_equal(add(1, 3), add(3, 1)) # both pass this !!\n  expect_equal(add(2, 5), add(5, 2)) # neither passes this\n})\n```\n:::\n\n\n::: {.callout-tip}\n* Cover all branches. \n\n* Make sure there aren't branches you don't expect.\n:::\n\n\n## Test-driven development\n\nTest Driven Development (TDD) uses a short development cycle for each new feature or component:\n\n1. Write tests that specify the component’s desired behavior.   \n    The tests will initially fail because the component does not yet exist.\n\n1. Create the minimal implementation that passes the test.\n\n1. Refactor the code to meet design standards, running the tests with each change to ensure correctness.\n\n##\n\n#### Why work this way?\n\n* Writing the tests may help you realize  \n    a. what arguments the function must take,   \n    b. what other data it needs,   \n    c. and what kinds of errors it needs to handle. \n\n* The tests define a specific plan for what the function must do.\n\n* You will catch bugs at the beginning instead of at the end (or never).\n\n* Testing is part of design, instead of a lame afterthought you dread doing.\n\n\n## Rules of thumb\n\n[Keep tests in separate files]{.secondary} \n\nfrom the code they test. This makes it easy to run them separately.\n\n[Give tests names.]{.secondary} \n\nTesting frameworks usually let you give the test functions names or descriptions. `test_1` doesn’t help you at all, but `test_tree_insert` makes it easy for you to remember what the test is for.\n\n[Make tests replicable.]{.secondary} \n\nIf a test involves random data, what do you do when the test fails? You need some way to know what random values it used so you can figure out why the test fails.\n\n## Rules of thumb\n\n[Use tests instead of the REPL.]{.secondary} \n\nIf you’re building a complicated function, write the tests in advance and use them to help you while you write the function. You'll waste time calling over and over at the REPL.\n\n[Avoid testing against another's code/package.]{.secondary} \n\nYou don't know the ins and outs of what they do. If they change the code, your tests will fail.\n\n[Test Units, not main functions.]{.secondary} \n\nYou should write small functions that do one thing. Test those. Don't write one huge 1000-line function and try to test that.\n\n[Avoid random numbers.]{.secondary} \n\nSeeds are not always portable.\n\n---\n\n::: {.callout-note}\n* `R`, use `{testthat}`. See the [Testing](http://r-pkgs.had.co.nz/tests.html) chapter from Hadley Wickham’s R Packages book.\n\n* `python` use `{pytest}`. A bit more user-friendly: [pytest](https://docs.pytest.org/en/latest/)\n:::\n\n\n## Assertions\n\n[Assertions]{.secondary} are things that must be true. Failure means \"Quit\". \n\n- There's no way to recover. \n- Think: passed in bad arguments.\n    \n\n::: {.cell hash='unit-tests_cache/revealjs/unnamed-chunk-4_b3cbd2083150b06f1dea9cc00e937583'}\n\n```{.python .cell-code}\ndef fit(data, ...):\n\n    for it in range(max_iterations):\n        # iterative fitting code here\n        ...\n\n        # Plausibility check\n        assert np.all(alpha >= 0), \"negative alpha\"\n        assert np.all(theta >= 0), \"negative theta\"\n        assert omega > 0, \"Nonpositive omega\"\n        assert eta2 > 0, \"Nonpositive eta2\"\n        assert sigma2 > 0, \"Nonpositive sigma2\"\n\n    ...\n```\n:::\n\n\nThe parameters have to be positive. Negative is impossible. No way to recover.\n\n\n## Errors\n\n[Errors]{.secondary} are for unexpected conditions that _could_ be handled by the calling code.\n\n* You could perform some action to work around the error, fix it, or report it to the user.\n\n#### Example:\n\n- I give you directions to my house. You get lost. You could recover.\n- Maybe retrace your steps, see if you missed a sign post.\n- Maybe search on Google Maps to locate your self in relation to a landmark.\n- If those fail, message me.\n- If I don't respond, get an Uber.\n- Finally, give up and go home.\n\n## Errors\n\nCode can also do this. It can `try` the function and `catch` errors to recover automatically.\n\nFor example:\n\n* Load some data from the internet. If the file doesn't exist, create some.\n\n* Run some iterative algorithm. If we haven't converged, restart from another place.\n\nCode can fix errors without user input. It can't fix assertions.\n\n\n## Best practices\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n[Do this]{.secondary}\n\n\n::: {.cell hash='unit-tests_cache/revealjs/unnamed-chunk-5_7a5eb5da60d5062502d9d771a581840b'}\n\n```{.r .cell-code}\nfoo <- function(x) {\n  if (x < 0) stop(x, \" is not positive\")\n}\n\nfoo <- function(x) {\n  if (x < 0) message(x, \" is not positive\")\n  # not useful unless we fix it too...\n}\n\nfoo <- function(x) {\n  if (x < 0) warning(x, \" is not positive\")\n  # not useful unless we fix it too...\n}\n\nfoo <- function(x) {\n  if (length(x) == 0)\n    rlang::abort(\"no data\", class=\"no_input_data\")\n}\n```\n:::\n\n\nThese allow error handling.\n:::\n\n\n::: {.column width=\"50%\"}\n\n[Don't do this]{.secondary}\n\n\n::: {.cell hash='unit-tests_cache/revealjs/unnamed-chunk-6_9d6fe011ca5baf308d87829a4a7d9e6e'}\n\n```{.r .cell-code}\nfoo <- function(x) {\n  if (x < 0) {\n    print(paste0(x, \" is not positive\"))\n    return(NULL)\n  }\n  ...\n}\n\nfoo <- function(x) {\n  if (x < 0) cat(\"uh oh.\")\n  ...\n}\n```\n:::\n\n\nCan't recover.\n\nDon't know what went wrong.\n\n:::\n::::\n\n---\n\nSee [here](https://36-750.github.io/practices/errors-exceptions/) for more details.\n\nSeems like overkill, \n\nbut when you run a big simulation that takes 2 weeks, \n\nyou don't want it to die after 10 days.   \n\n\nYou want it to recover.\n\n\n## Practice\n\n#### Gradient ascent.\n\n* Suppose we want to find $\\max_x f(x)$.\n\n* We repeat the update $x \\leftarrow x + \\gamma f'(x)$ until convergence, for some $\\gamma > 0$.\n\n#### Poisson likelihood.\n\n* Recall the likelihood: $L(\\lambda; y_1,\\ldots,y_n) = \\prod_{i=1}^n \\frac{\\lambda^{y_i} \\exp(-\\lambda)}{y_i!}$\n\n[Goal:]{.secondary} find the MLE for $\\lambda$ using gradient ascent\n\n---\n\n## Deliverables, 2 R scripts\n\n1. A function that evaluates the log likelihood. (think about sufficiency, ignorable constants)\n1. A function that evaluates the gradient of the log likelihood. \n1. A function that *does* the optimization. \n    a. Should take in data, the log likelihood and the gradient.\n    b. Use the loglikelihood to determine convergence. \n    c. Pass in any other necessary parameters with reasonable defaults.\n1. A collection of tests that make sure your functions work.\n\n\n$$\n\\begin{aligned} \nL(\\lambda; y_1,\\ldots,y_n) &= \\prod_{i=1}^n \\frac{\\lambda^{y_i} \\exp(-\\lambda)}{y_i!}\\\\\nx &\\leftarrow x + \\gamma f'(x)\n\\end{aligned}\n$$",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}